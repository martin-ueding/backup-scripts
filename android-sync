#!/bin/bash
# Copyright © 2013 Martin Ueding <dev@martin-ueding.de>

# Copies files onto Android devices using SSH. The devices should run the
# “SSHelper” program that provides an SSH server for Android.

set -u

shopt -s nullglob
shopt -s extglob

# Directories with PDF files that should be copied onto the device.
pdfdirs=(

"$HOME/Dokumente/2012-LaTeX_Kurs"
"$HOME/Dokumente/2013-LaTeX_Kurs_VWL/Kursunterlagen"
"$HOME/Dokumente/Anleitungen"
"$HOME/Dokumente/Aufsaetze/Brandon_Patrick_In_Space"
"$HOME/Dokumente/Informationen"
"$HOME/Dokumente/Nachhilfe"
"$HOME/Dokumente/Physik_Dokumente"
"$HOME/Dokumente/Schule/Abizeitung/Abizeitung-300.pdf"
"$HOME/Dokumente/Spektrum"

)

studiumpdfdirs=(

"$HOME/Dokumente/Studium/EBooks"
"$HOME/Dokumente/Studium/math140"
"$HOME/Dokumente/Studium/math240"
"$HOME/Dokumente/Studium/math340"
"$HOME/Dokumente/Studium/Modulhandbücher"
"$HOME/Dokumente/Studium/physik220"
"$HOME/Dokumente/Studium/physik312"
"$HOME/Dokumente/Studium/physik321"
"$HOME/Dokumente/Studium/physik411"
"$HOME/Dokumente/Studium/physik421"
"$HOME/Dokumente/Studium/physik441"
"$HOME/Dokumente/Studium/physik541"

)

backupdirs=(

"$HOME/Dokumente/Studium"

)

# Folders where data will build up on the device.
bins=(

"DCIM"
"Download"
"Locus/export"
"OpenGPSTracker"
"Pictures/Screenshots"
"TODO"

)

# Files that should be copied into the ``$HOME`` on the devices.
dotfiles=(

"$HOME/.bashrc"
"$HOME/.vimrc"

)

# Cleanup actions.
#
# Positional arguments:
#   DROPFOLDER      bins to empty
cleanup() {
	# Delete the dropfolder, if it is empty.
	rmdir --ignore-fail-on-non-empty "$1"
}

# Copies backup folders onto the device.
#
# Options:
#   -p PORT         port for SSH
#   -t TARGET       target folder on device
#
# Positional arguments:
#   BACKUPDIR ...   directory with PDF files
copy-backupdirs() {
	local from
	local frombase
	local opt
	local port
	local target
	local targetfolder

	OPTIND=1
	while getopts "p:t:" opt
	do
		case "$opt" in
			p)
				port="$OPTARG"
				;;
			t)
				target="$OPTARG"
				;;
		esac
	done
	shift $((OPTIND-1))

	print-heading "copying backup files to device"

	for from
	do
		frombase="${from#/home/*/}"
		targetfolder="$target/${frombase%/*}"
		myrsync -p "$port" -- --delete "$from" "$targetfolder/"
	done
}

# Copies the contents of the bins.
#
# Options:
#   -d DROPFOLDER   folder on computer
#   -p PORT         port for SSH
#   -t TARGET       target folder on device
#
# Positional arguments:
#   BIN ...         bins to empty
copy-bins() {
	local bin
	local dropfolder
	local folder
	local opt
	local port
	local target

	folder="$1"

	OPTIND=1
	while getopts "d:p:t:" opt
	do
		case "$opt" in
			d)
				dropfolder="$OPTARG"
				;;
			p)
				port="$OPTARG"
				;;
			t)
				target="$OPTARG"
				;;
		esac
	done
	shift $((OPTIND-1))

	for bin
	do
		print-heading "move $bin to computer"

		myrsync -p "$port" -- "$target/$bin/" "$dropfolder"
		ssh -p "$port" "$ip" "rm -frv /sdcard/$bin/* /sdcard/$bin/.??*"
	done
}

# Copies dotfiles to the remote device.
#
# Options:
#   -p PORT         port for SSH
#   -t TARGET       target folder on device
#
# Positional arguments:
#   DOTFILE ...     dotfiles to copy
copy-dotfiles() {
	local opt
	local port
	local target

	OPTIND=1
	while getopts "p:t:" opt
	do
		case "$opt" in
			p)
				port="$OPTARG"
				;;
			t)
				target="$OPTARG"
				;;
		esac
	done
	shift $((OPTIND-1))

	print-heading "Copying dotfiles files to device"

	myrsync -p "$port" -- "$@" "$target/"
}

# Copies all the music to the device.
#
# Options:
#   -p PORT         SSH port to use
#
# Positional arguments:
#   TARGET          target folder
copy-latex-documentation() {
	local headerfile
	local opt
	local package
	local pdffile
	local pdffiles
	local port
	local target
	local usepackage_regex

	headerfile="$HOME/Vorlagen/header.tex"
	pdffiles=()
	usepackage_regex='\usepackage.*\{(.*)\}'

	OPTIND=1
	while getopts "p:" opt
	do
		case "$opt" in
			p)
				port="$OPTARG"
				;;
		esac
	done
	shift $((OPTIND-1))

	target="$1"

	print-heading "Copying LaTeX documentation to device"

	if ! [[ -f "$headerfile" ]]
	then
		echo "$headerfile does not exist."
		return 0
	fi

	# Go through the include statements in the header file.
	while read line
	do
		if [[ "$line" =~ $usepackage_regex ]]
		then
			package="${BASH_REMATCH[1]}"
			echo "Looking for $package.pdf …"

			pdffile="$(locate --limit 1 "*/$package.pdf")"
			if [[ -n "$pdffile" ]]
			then
				if [[ -z "${pdffiles[@]-}" ]]
				then
					pdffiles=("$pdffile")
				else
					pdffiles=("${pdffiles[@]}" "$pdffile")
				fi
			fi
		fi
	done < "$headerfile"

	echo "${pdffiles[@]}"

	myrsync -p "$port" -- --delete "${pdffiles[@]}" "$target/"
}

# Copies all the music to the device.
#
# Options:
#   -p PORT         SSH port to use
#
# Positional arguments:
#   TARGET          target folder
copy-music() {
	local opt
	local port
	local target_music

	OPTIND=1
	while getopts "p:" opt
	do
		case "$opt" in
			p)
				port="$OPTARG"
				;;
		esac
	done
	shift $((OPTIND-1))

	target_music="$1"

	print-heading "Copying MP3 files to device"

	myrsync -p "$port" -- --size-only --delete \
		--force --exclude-from "/home/mu/.config/syncscripts/handy_musik.txt" \
		"/home/mu/.cache/mp3_packer/128/home/mu/Musik/Musik/" \
		"/home/mu/.cache/mp3_packer/128/home/mu/Musik/Podcasts/" \
		"$target_music/"
}

# Copies PDF files to the device using ``copy-single-pdf-folder``.
#
# Options:
#   -p PORT         port for SSH
#   -t TARGET       target folder on device
#
# Positional arguments:
#   PDFDIR ...      directory with PDF files
copy-pdffiles() {
	local opt
	local pdfdir
	local port
	local target

	OPTIND=1
	while getopts "p:t:" opt
	do
		case "$opt" in
			p)
				port="$OPTARG"
				;;
			t)
				target="$OPTARG"
				;;
		esac
	done
	shift $((OPTIND-1))

	print-heading "copying PDF files to device"

	for pdfdir
	do
		copy-single-pdf-folder -p "$port" -t "$target" "$pdfdir"
	done
}

# Copies a folder with PDFs to the device.
#
# Options:
#   -b BASE         base on the computer
#   -p PORT         port for SSH
#   -t TARGET       target folder on device
#
# Positional arguments:
#   FROM            folder on the computer
copy-single-pdf-folder() {
	local from
	local frombase
	local opt
	local target

	OPTIND=1
	while getopts "b:p:t:" opt
	do
		case "$opt" in
			b)
				frombase="$OPTARG"
				;;
			p)
				port="$OPTARG"
				;;
			t)
				target="$OPTARG"
				;;
		esac
	done
	shift $((OPTIND-1))

	from="$1"
	frombase="${from#/home/*/}"
	target="$target_pdf/${frombase%/*}"

	echo "${cyan}Folder $from to $target${reset}"

	ssh -p "$port" "$ip" "mkdir -p \"${target#*:}\""
	myrsync -p "$port" -- --delete --include='*.pdf' --include='*/' \
		--exclude='*' "$from" "$target/"

	echo
}

# Gives the user access rights to all the files in the dropfolder.
#
# Apparently, the files that are copied from the device have their permissions
# preserved. Since the user ID is different, the user who calls this script
# does not have permissions on the files and folders.
#
# Positional arguments:
#   DROPFOLDER      folder on computer
fix-permissions() {
	local dropfolder

	dropfolder="$1"

	print-heading "Fix permissions in $dropfolder"
	find "$dropfolder" -type d -exec chmod u+rwx '{}' \;
	find "$dropfolder" -type f -exec chmod u+rw '{}' \;
}

# Gathers colorcodes.
#
# It will set the variables for use within the program:
#
#     black, blue, cyan, green, orange, purple, red, white and bold, reset
gather-colorcodes() {
	if [[ -x /usr/bin/tput ]] && tput setaf 1 >&/dev/null
	then
		bold="$(tput bold)"

		black="$(tput setaf 0)"
		blue="$(tput setaf 4)"
		cyan="$(tput setaf 6)"
		green="$(tput setaf 2)"
		orange="$(tput setaf 3)"
		purple="$(tput setaf 5)"
		red="$(tput setaf 1)"
		white="$(tput setaf 7)"

		reset="$(tput sgr0)"
	else
		bold=

		black=
		blue=
		cyan=
		green=
		orange=
		purple=
		red=
		white=

		reset=
	fi
}

# Retrives the hostname from the device.
#
# Options:
#   -p PORT         SSH port to use
#   -t TARGET       target folder
get-hostname() {
	local port
	local target
	local tempfile

	OPTIND=1
	while getopts "p:t:" opt
	do
		case "$opt" in
			p)
				port="$OPTARG"
				;;
			t)
				target="$OPTARG"
				;;
		esac
	done
	shift $((OPTIND-1))

	tempfile="$(mktemp)"

	myrsync -p "$port" -- "$target/hostname.txt" "$tempfile" &> /dev/null

	cat "$tempfile"

	rm -f "$tempfile"
}

# Main function of this script.
main() {
	local full_ip_regex
	local ip
	local own_ip
	local partial_ip_regex
	local subnet

	gather-colorcodes

	full_ip_regex='^ *([[:digit:]]{1,3})\.([[:digit:]]{1,3})\.([[:digit:]]{1,3})\.([[:digit:]]{1,3}) *$'
	partial_ip_regex='^([[:digit:]]{1,3})$'
	own_ip="$(hostname -I)"

	if [[ "$own_ip" =~ $full_ip_regex ]]
	then
		subnet="${BASH_REMATCH[1]}.${BASH_REMATCH[2]}.${BASH_REMATCH[3]}"
	fi

	if [[ "${1:-}" =~ $full_ip_regex ]]
	then
		ip="$1"
		sync-device "$ip"
	elif [[ "${1:-}" =~ $partial_ip_regex ]]
	then
		ip="$subnet.$1"
		sync-device "$ip"
	else
		echo "usage: $0 IP"
		exit 2
	fi
}

# Wrapper for rsync with all the options.
#
# Options:
#   -p PORT         port for SSH
#
# Positional arguments:
#   OPTIONS         other rsync options and arguments
myrsync() {
	local opt
	local port

	OPTIND=1
	while getopts "p:" opt
	do
		case "$opt" in
			p)
				port="$OPTARG"
				;;
		esac
	done
	shift $((OPTIND-1))

	rsync --rsh="ssh -p $port" --progress -hlmrv --size-only --ignore-errors \
		--exclude=.thumbnails --copy-links "$@"
}

# Checks whether the given host is reachable.
#
# Positional arguments:
#   IP              IP address to check
#
# Exit status:
#   the exit status of ping
ping-test() {
	ping -c 1 -w 2 "$1" &> /dev/null
}

# Prints a colored heading.
#
# Positional arguments
#   TEXT            text to print
print-heading() {
	echo
	echo "${green}$1${reset}"
	echo
}

# Prints a colored “NEXUS” banner.
print-nexus() {
	echo "│╲   │  ┌──  ${blue}╲  ${red}╱${reset}  │   │  ╱──"
	echo "│ ╲  │  │__   ${blue}╲${red}╱${reset}   │   │  ╲__"
	echo "│  ╲ │  │     ${orange}╱${green}╲${reset}   │   │     ╲"
	echo "│   ╲│  └── ${orange} ╱  ${green}╲${reset}  └───┘   __╱"
}

# Shows the disk usage on the device.
#
# Options:
#   -i IP           IP address of the device
#   -p PORT         port for SSH
show-disk-usage() {
	local ip
	local port

	OPTIND=1
	while getopts "p:i:" opt
	do
		case "$opt" in
			p)
				port="$OPTARG"
				;;
			i)
				ip="$OPTARG"
				;;
		esac
	done
	shift $((OPTIND-1))

	result="$(ssh -p "$port" "$ip" df -h /sdcard | grep /sdcard | awk '{print $4}')"

	echo
	echo "$result of /sdcard used"
}

# Stashes the GPX files into the target directory.
#
# Positional arguments
#   DROPFOLDER      Source folder
stash-gpx-files() {
	local dropfolder="$1"
	local gpxfile

	print-heading "Move GPX files into target folder"

	shopt -s nullglob

	for gpxfile in "$dropfolder"/*.gpx
	do
		mv -v "$gpxfile" "$HOME/Dokumente/GPS/"
	done
}

# Performs the syncing. This functions pretty much calls all other functions.
#
# Positional arguments
#   IP              IP address of the device
sync-device() {
	local dropfolder
	local hostname
	local ip
	local port
	local target
	local target_music
	local target_pdf

	ip="$1"

	if ! ping-test "$ip"
	then
		echo "${red}Device is not reachable. Aborting.${reset}"
		exit 1
	fi

	port="2222"
	target="$ip:/sdcard"
	target_music="$target/Music"
	target_pdf="$target/PDF"

	dropfolder="$(mktemp -d "$HOME/TODO/android-sync-$(date +%Y%m%dT%H%M%S%z)-XXX")"

	trap "cleanup '$dropfolder'" EXIT

	hostname="$(get-hostname -p "$port" -t "$target")"

	echo "${bold}Syncing $hostname @ $ip${reset}"

	case "$hostname" in
		"Nexus 10")
			print-nexus
			;;
	esac

	show-disk-usage -i "$ip" -p "$port"

	copy-bins -d "$dropfolder" -p "$port" -t "$target" "${bins[@]}"

	fix-permissions "$dropfolder"

	stash-gpx-files "$dropfolder"

	case "$hostname" in
		"Nexus 10")
			copy-dotfiles -p "$port" -t "$target" "${dotfiles[@]}"
			copy-pdffiles -p "$port" -t "$target" "${studiumpdfdirs[@]}"
			;;
		"Xperia Mini Pro")
			copy-backupdirs -p "$port" -t "$target" "${backupdirs[@]}"
			copy-music -p "$port" "$target_music"
			;;
	esac

	copy-latex-documentation -p "$port" "$target/PDF/LaTeX"
	copy-pdffiles -p "$port" -t "$target" "${pdfdirs[@]}"

	show-disk-usage -i "$ip" -p "$port"

	backup-status update "$hostname"
}

main "$@"
